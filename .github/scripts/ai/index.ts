#!/usr/bin/env node
/**
 * AI Command Handler for GitHub Pull Request Reviews
 *
 * This script processes /ai commands in PR review comments and responds with AI-generated suggestions.
 */

import { PullRequestReviewCommentCreatedEvent } from "@octokit/webhooks-definitions/schema";
import * as github from "@actions/github";
import OpenAI from "openai";

interface ChatMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

function stripSlashAi(s: string): string {
  return s.replace(/\/ai\s+/i, "").trim();
}

const AI_REPLY_MARKER = "<!-- ü§ñ Generated by AI assistant -->";

function extractDiff(diff: string, path: string): string {
  return (
    diff.split(/diff\s+--git\s+/g).find(d => d.startsWith(`a/${path}`)) || ""
  );
}

/**
 * Annotates a diff hunk to highlight the lines that a GitHub PR review comment refers to.
 *
 * This function parses a Git diff hunk and adds visual annotations to indicate which specific
 * lines are being commented on. It handles both single-line and multi-line comments, as well
 * as comments on the left side (deletions) or right side (additions) of the diff.
 *
 * @param diffHunk - The Git diff hunk string (e.g., "@@ -10,5 +10,6 @@ context\n-old line\n+new line")
 * @param line - The end line number of the comment (for single-line comments, this is the only line)
 * @param startLine - The start line number for multi-line comments
 * @param side - Which side of the diff the comment is on: "LEFT" (deletions) or "RIGHT" (additions)
 * @param startSide - Which side the multi-line comment starts on
 * @returns The annotated diff hunk with "‚Üê COMMENTED LINE" markers
 *
 * @example
 * // Single line comment on a new line (addition)
 * const diffHunk = `@@ -10,3 +10,4 @@
 *  function example() {
 * +  console.log("new line");
 *    return true;
 *  }`;
 * const result = annotateDiffHunk(diffHunk, 11, null, "RIGHT", null);
 * // Returns:
 * // @@ -10,3 +10,4 @@
 * //  function example() {
 * // +  console.log("new line"); ‚Üê COMMENTED LINE
 * //    return true;
 * //  }
 *
 * @example
 * // Multi-line comment spanning lines 10-12 on the right side
 * const diffHunk = `@@ -10,5 +10,5 @@
 * +  const a = 1;
 * +  const b = 2;
 * +  const c = 3;
 *    return a + b + c;`;
 * const result = annotateDiffHunk(diffHunk, 12, 10, "RIGHT", "RIGHT");
 * // Returns:
 * // @@ -10,5 +10,5 @@
 * // +  const a = 1; ‚Üê COMMENTED LINE
 * // +  const b = 2; ‚Üê COMMENTED LINE
 * // +  const c = 3; ‚Üê COMMENTED LINE
 * //    return a + b + c;
 *
 * @example
 * // Comment on a deleted line
 * const diffHunk = `@@ -15,4 +15,3 @@
 *    function old() {
 * -    console.log("old implementation");
 *      return false;
 *    }`;
 * const result = annotateDiffHunk(diffHunk, 16, null, "LEFT", null);
 * // Returns:
 * // @@ -15,4 +15,3 @@
 * //    function old() {
 * // -    console.log("old implementation"); ‚Üê COMMENTED LINE
 * //      return false;
 * //    }
 */
function annotateDiffHunk(
  diffHunk: string,
  line?: number | null,
  startLine?: number | null,
  side?: "LEFT" | "RIGHT" | null,
  startSide?: "LEFT" | "RIGHT" | null
): string {
  const lines = diffHunk.split("\n");
  const annotatedLines: string[] = [];

  let leftLineNum = 0;
  let rightLineNum = 0;

  // Parse the diff header to get starting line numbers
  const headerMatch = lines[0].match(/@@\s+-(\d+),?\d*\s+\+(\d+),?\d*\s+@@/);
  if (headerMatch) {
    leftLineNum = parseInt(headerMatch[1]) - 1;
    rightLineNum = parseInt(headerMatch[2]) - 1;
  }

  for (let i = 0; i < lines.length; i++) {
    const currentLine = lines[i];
    let annotation = "";

    // Skip the diff header
    if (i === 0 && currentLine.startsWith("@@")) {
      annotatedLines.push(currentLine);
      continue;
    }

    // Determine current line numbers based on diff markers
    if (currentLine.startsWith("-")) {
      leftLineNum++;
      // Check if this line should be highlighted
      if (
        shouldHighlightLine(
          leftLineNum,
          line,
          startLine,
          "LEFT",
          side,
          startSide
        )
      ) {
        annotation = " ‚Üê COMMENTED LINE";
      }
    } else if (currentLine.startsWith("+")) {
      rightLineNum++;
      // Check if this line should be highlighted
      if (
        shouldHighlightLine(
          rightLineNum,
          line,
          startLine,
          "RIGHT",
          side,
          startSide
        )
      ) {
        annotation = " ‚Üê COMMENTED LINE";
      }
    } else if (currentLine.startsWith(" ")) {
      leftLineNum++;
      rightLineNum++;
      // For context lines, check both sides
      if (
        shouldHighlightLine(
          leftLineNum,
          line,
          startLine,
          "LEFT",
          side,
          startSide
        ) ||
        shouldHighlightLine(
          rightLineNum,
          line,
          startLine,
          "RIGHT",
          side,
          startSide
        )
      ) {
        annotation = " ‚Üê COMMENTED LINE";
      }
    }

    annotatedLines.push(currentLine + annotation);
  }

  return annotatedLines.join("\n");
}

function shouldHighlightLine(
  currentLineNum: number,
  targetLine: number | null | undefined,
  targetStartLine: number | null | undefined,
  currentSide: "LEFT" | "RIGHT",
  targetSide: "LEFT" | "RIGHT" | null | undefined,
  targetStartSide: "LEFT" | "RIGHT" | null | undefined
): boolean {
  // If no target line specified, don't highlight
  if (!targetLine && !targetStartLine) {
    return false;
  }

  // Single line comment
  if (targetLine && !targetStartLine) {
    return (
      currentLineNum === targetLine &&
      (!targetSide || currentSide === targetSide)
    );
  }

  // Multi-line comment
  if (targetStartLine && targetLine) {
    const startSide = targetStartSide || targetSide || "RIGHT";
    const endSide = targetSide || "RIGHT";

    // Handle same-side range
    if (startSide === endSide && currentSide === startSide) {
      return currentLineNum >= targetStartLine && currentLineNum <= targetLine;
    }

    // Handle cross-side range (less common)
    if (startSide !== endSide) {
      if (currentSide === startSide) {
        return currentLineNum >= targetStartLine;
      } else if (currentSide === endSide) {
        return currentLineNum <= targetLine;
      }
    }
  }

  return false;
}

async function main(): Promise<void> {
  const { GITHUB_TOKEN } = process.env;
  if (!GITHUB_TOKEN) {
    console.error("‚ùå GITHUB_TOKEN environment variable is required");
    process.exit(1);
  }
  const {
    repository: {
      owner: { login: repoOwner },
      name: repoName,
    },
    comment: {
      id: commentId,
      in_reply_to_id: inReplyToId,
      body: commentBody,
      user: { login: commentUser },
      author_association: authorAssociation,
      path,
      line,
      start_line: startLine,
      // original_line: originalLine,
      // original_start_line: originalStartLine,
      commit_id: commitId,
      diff_hunk: diffHunk,
      side,
      start_side: startSide,
    },
    pull_request: { number: prNumber },
  } = github.context.payload as PullRequestReviewCommentCreatedEvent;

  if (
    ["owner", "member", "collaborator"].indexOf(
      authorAssociation.toLowerCase()
    ) === -1
  ) {
    console.error(
      `‚ùå User ${commentUser} (${authorAssociation}) does not have permission to use the /ai command`
    );
    process.exit(1);
  }

  // Initialize GitHub API
  const octokit = github.getOctokit(GITHUB_TOKEN);

  // 1. Extract the code that the comment refers to
  let code = "";
  if (diffHunk === "") {
    // Comment on a file
    const { data: diff } = await octokit.rest.pulls.get({
      owner: repoOwner,
      repo: repoName,
      pull_number: prNumber,
      mediaType: {
        format: "diff",
      },
    });
    code = extractDiff(diff.toString(), path);
  } else {
    // Comment on lines
    code = annotateDiffHunk(diffHunk, line, startLine, side, startSide);
  }

  const systemMessage: ChatMessage = {
    role: "system",
    content: [
      "You are an expert code reviewer helping with a GitHub pull request.",
      `File: ${path}`,
      "",
      "```",
      code,
      "```",
      "",
      "Please provide a helpful response. Keep it concise and focused on the specific request.",
      "If suggesting code changes, use proper markdown formatting with code blocks.",
    ].join("\n"),
  };

  // 2. Construct the request to the AI model
  let messages: ChatMessage[];
  if (inReplyToId) {
    const allComments = await octokit.paginate(
      octokit.rest.pulls.listReviewComments,
      {
        owner: repoOwner,
        repo: repoName,
        pull_number: prNumber,
        per_page: 100,
      }
    );
    const comments: ChatMessage[] = allComments
      .filter(comment => comment.in_reply_to_id === inReplyToId)
      .sort(
        (a, b) =>
          new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
      )
      .map(({ body }) => ({
        role: body.includes(AI_REPLY_MARKER) ? "assistant" : "user",
        content: stripSlashAi(body.replace(AI_REPLY_MARKER, "").trim()),
      }));

    const rootComment = await octokit.rest.pulls.getReviewComment({
      owner: repoOwner,
      repo: repoName,
      comment_id: inReplyToId,
    });
    messages = [
      systemMessage,
      {
        role: "user",
        content: stripSlashAi(rootComment.data.body).trim(),
      },
      ...comments,
    ];
  } else {
    messages = [
      systemMessage,
      {
        role: "user",
        content: stripSlashAi(commentBody).trim(),
      },
    ];
  }

  const client = new OpenAI({
    apiKey: GITHUB_TOKEN,
    baseURL: "https://models.github.ai/inference",
  });

  for (const { role, content } of messages) {
    console.log(`[${role}]:\n${content}`);
  }

  const completion = await client.chat.completions.create({
    model: "openai/gpt-4.1",
    messages: messages,
  });

  // 4. Post the AI response as a comment
  const aiResponse =
    completion.choices[0].message.content?.trim() || "‚ùå No response generated";

  const responseBody = `${aiResponse}\n\n${AI_REPLY_MARKER}`;
  await octokit.rest.pulls.createReviewComment({
    owner: repoOwner,
    repo: repoName,
    pull_number: prNumber,
    body: responseBody,
    in_reply_to: inReplyToId || commentId,
    commit_id: commitId,
    path,
  });
}

// Run the main function
main().catch(console.error);
